<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Process</title><link href="http://changy-.github.io/" rel="alternate"></link><link href="http://changy-.github.io/feeds/changy.atom.xml" rel="self"></link><id>http://changy-.github.io/</id><updated>2015-12-28T21:43:00-05:00</updated><entry><title>Xiao Mi band protocol analyze</title><link href="http://changy-.github.io/articles/xiao-mi-band-protocol-analyze.html" rel="alternate"></link><updated>2015-12-28T21:43:00-05:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-12-28:articles/xiao-mi-band-protocol-analyze.html</id><summary type="html">&lt;h1&gt;Xiao Mi band protocol analyze&lt;/h1&gt;
&lt;p&gt;I have used Mi band for 2 months and during this 2 months I analyzed how Bluetooth Low Energy protocol works and how Mi Fit App communicates with Mi band. There are 2 parts in this report. The first part is about data analyze which is recorded by Mi Fit App and the second is about BLE communication.&lt;/p&gt;
&lt;h2&gt;Data analyze&lt;/h2&gt;
&lt;p&gt;Mi Fit App saves all data in /data/data/com.xiaomi.hm.health/, where only Mi Fit itself and root App can reach. So I think it’s not possible for other Apps on Android to steal data, which is mentioned in initial “Draft Scope”. And Mi Fit saves most data in /databases and /shared_prefs.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2016:54:09.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;In P2, user-db saves user information like name and sports.db saves your running data. And all of these data have been pushed into vendor’s server. When you change the phone or Mi band, the App will download those data from server. In P3, there also are some data like configure file.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://forum.xda-developers.com/general/accessories/xiaomi-mi-band-data-extraction-t3019156"&gt;Xmxm&lt;/a&gt; and his friends have done much to extract, clean and analyze Mi band data. Here, I use their tools to extract and analyze data. P4 shows the statistical chart about sleep and activity and P5 shows data of daily steps.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2016:57:41.png?raw=true" /&gt;&lt;/p&gt;
&lt;h2&gt;BLE communication&lt;/h2&gt;
&lt;h3&gt;Bluetooth Low Energy Protocol&lt;/h3&gt;
&lt;p&gt;Bluetooth low energy is a wireless personal area network technology designed and marketed by the Bluetooth Special Interest Group aimed at novel applications in the healthcare, fitness, beacons, security, and home entertainment industries.&lt;/p&gt;
&lt;p&gt;Bluetooth Smart (low energy) wireless technology features:
 - Ultra-low peak, average and idle mode power consumption
 - Ability to run for years on standard coin-cell batteries
 - Low cost
 - Multi-vendor interoperability
 - Enhanced range&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2016:59:33.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;As showed in P6, it looks like TCP/IP Protocol Stack and they are very similar. The bottom 3 layers
are designed for hardware, paired and encryption. The top 4 layers (Host and Application layers)
are encapsulated for applications or other operating systems. So, I focus more on the top layers,
more precisely on GATT server, in analyzing how Mi band communicates with Mi Fit App.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:00:42.png?raw=true" /&gt;
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:01:09.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;The attributes in a GATT server are grouped into services, each of which can contain zero or more characteristics. These characteristics, in turn, can include zero or more descriptors.&lt;/p&gt;
&lt;p&gt;P8 illustrates an instance of the HRS on a fictitious server. This would not be the only service contained in the server, so you can see this as a partial slice of the complete set of attributes that a client could access. And everything in BLE Protocol, like service, characteristics and descriptor, is located by a UUID (16bits or 128bits).&lt;/p&gt;
&lt;p&gt;So, communication between Mi band and Mi Fit App is using many UUIDs so that there won’t be much useful information by sniffing BLE data. And what I did is combining sniffing and reversing engineer to analyze the processing of communication.&lt;/p&gt;
&lt;h3&gt;Analyze Mi band communication protocol&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:02:52.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;First of all, let’s see how many services and characteristics MI Fit App has.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:03:44.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;From P9, we can see there are 6 services 0x1800, 0x1801, 0xfee0, 0xfee1, 0xfee7 and 0x1802. And 3 of them, 0x1800, 0x1801 and 0x1802, have been approved by Bluetooth SIG (Special Interest Group), which means they have specific meanings and we can find them on &lt;a href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx"&gt;BLE Services&lt;/a&gt;. So, services 0xfee0, 0xfee1, 0xfee7 are customized by the Vendor and only they know the meaning of every UUID.&lt;/p&gt;
&lt;p&gt;As for characteristics, there are over 20 characteristics and most of them belong to 0xfee0 service. The rest 2 services, 0xfee1 and 0xfee7, are not realized in Mi Fit App. Maybe the vendor will complete them in the following version.&lt;/p&gt;
&lt;p&gt;Table 2 shows the meaning of every characteristic in 0xfee0 service.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:05:51.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;If I get data 0xff02 and its value is 60-09-4d-49, how to explain this? In fact, every value has its specific definition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0xff01, DEVICE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The length of value is 16 bytes.
- Byte[0-3] --&amp;gt; device ID
- Byte[4-7] --&amp;gt; profile version
- Byte[8-9] --&amp;gt; feature
- Byte[10-11] --&amp;gt; appearance
- Byte[12-13] --&amp;gt; hardware version
- Byte[14-15] --&amp;gt; firmware version&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff02, DEVICE_NAME&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hex to String&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff03, NOTIFICATION&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mi Fit App gets descriptor 0x2902, but I can’t figure out what it’ll do next. Maybe it’s used for notifying when the band have new data to upload.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff04, USER_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(get data from Mi cloud)
- Byte[0-3] --&amp;gt; user ID
- Byte[4] --&amp;gt; gender (0:female, 1:male)
- Byte[5] --&amp;gt; age
- Byte[6] --&amp;gt; height
- Byte[7] --&amp;gt; weight
- Byte[8-11] --&amp;gt; alias&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff05, CONTROL_POINT&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Factory reset --&amp;gt; write 9 to control point&lt;/li&gt;
&lt;li&gt;Reboot --&amp;gt; write 12&lt;/li&gt;
&lt;li&gt;Send notification --&amp;gt; write 8 and xxx&lt;/li&gt;
&lt;li&gt;Stop motor vibrate --&amp;gt; write 19&lt;/li&gt;
&lt;li&gt;Sync --&amp;gt; write 11&lt;/li&gt;
&lt;li&gt;Stop sync data --&amp;gt; write 17&lt;/li&gt;
&lt;li&gt;Get sensor data --&amp;gt; 18 and 1 --&amp;gt; enable --&amp;gt; 18 and 0 --&amp;gt; diable&lt;/li&gt;
&lt;li&gt;Get activities --&amp;gt; write 6&lt;/li&gt;
&lt;li&gt;Send firmware info --&amp;gt; write 7 and info&lt;/li&gt;
&lt;li&gt;Set color theme --&amp;gt; Write 14, R, G, B, D to Characteristic 0xFF05 (CONTROL_POINT). Where R, G, B, is a byte representing red, green blue value and D is 0 (don't flash) or 1 (quickly flash Color).&lt;/li&gt;
&lt;li&gt;Set goal --&amp;gt; write 5 and goal&lt;/li&gt;
&lt;li&gt;Set real time steps --&amp;gt; write 16 and steps (2 bytes)&lt;/li&gt;
&lt;li&gt;Set time --&amp;gt; write 4 and times (12 bytes)&lt;/li&gt;
&lt;li&gt;Set wear location --&amp;gt; write 15 and 1 para(left , right or neck)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff06, REALTIME_STEPS&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hex --&amp;gt; Int&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff07, ACTIVITY_DATA&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Byte[0] --&amp;gt; category (126 --&amp;gt; run)&lt;/li&gt;
&lt;li&gt;Byte[1] --&amp;gt; intensity&lt;/li&gt;
&lt;li&gt;Byte[2] --&amp;gt; steps&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff08, FIRMWARE_DATA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I can’t figure out&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0xff09, LE_PARAMS&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;- connIntMin: 0xffff &amp;amp; (0xff &amp;amp; byte[0]&lt;/th&gt;
&lt;th&gt;(0xff &amp;amp; byte[1]) &amp;lt;&amp;lt; 8)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- latency:&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- 0xffff &amp;amp; (0xff &amp;amp; byte[4] \&lt;/td&gt;
&lt;td&gt;(0xff &amp;amp; byte[5]) &amp;lt;&amp;lt; 8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- timeout:&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- 0xffff &amp;amp; (0xff &amp;amp; byte[6] \&lt;/td&gt;
&lt;td&gt;(0xff &amp;amp; byte[7]) &amp;lt;&amp;lt; 8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- connInt:&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- 0xffff &amp;amp; (0xff &amp;amp; byte[8] \&lt;/td&gt;
&lt;td&gt;(0xff &amp;amp; byte[9]) &amp;lt;&amp;lt; 8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- advInt:&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- 0xffff &amp;amp; (0xff &amp;amp; byte[10] \&lt;/td&gt;
&lt;td&gt;(0xff &amp;amp; byte[11]) &amp;lt;&amp;lt; 8).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff0a, DATE_TIME&lt;/strong&gt;
12 bytes, Year-month-day-hour-minute-second- Year-month-day-hour-minute-second
The first one is Gregorian and the second one is lunar.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0xff0b, STATISTICS&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Byte[0] --&amp;gt; wake (ms)&lt;/li&gt;
&lt;li&gt;Byte[1] --&amp;gt; vibrate (ms)&lt;/li&gt;
&lt;li&gt;Byte[2] --&amp;gt; light (ms)&lt;/li&gt;
&lt;li&gt;Byte[3] --&amp;gt; conn (s)&lt;/li&gt;
&lt;li&gt;Byte[4] --&amp;gt; adv (s)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff0c, BATTERY&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Byte[0] --&amp;gt; level in%&lt;/li&gt;
&lt;li&gt;Byte[1-6] --&amp;gt; year (should plus 2000) -month-day-hour-minute-second&lt;/li&gt;
&lt;li&gt;Byte[7-8] --&amp;gt; charge times&lt;/li&gt;
&lt;li&gt;Byte[9] --&amp;gt; status (1 = Battery low, 2 = Battery charging, 3 = Battery full (charging), 4 = Not charging)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff0d, TEST&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Write 2 to Characteristic 0xFF0D (TEST). Your Mi Band will do crazy things (LED flashing,vibrate)&lt;/li&gt;
&lt;li&gt;Write 1 to Characteristic 0xFF0D (TEST) --&amp;gt; disconnect&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;0xff0e, SENSOR_DATA&lt;/strong&gt;
I can’t figure out the meaning.&lt;/p&gt;
&lt;p&gt;Now, I know every UUID’s meaning and I can analyze the sniffed BLE data.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:20:42.png?raw=true" /&gt;
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-29%2017:22:49.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;We can see the Master (Android phone) want to read the data in handle 0x002c. According to P9,it’s between 0x0010 and 0x0039. So the service Master wanted is 0xffe0. Finally, we can locate the exact characteristic by 0x002c in appendix. It’s 0xff0c, which means the Master wants information about battery.&lt;/p&gt;
&lt;p&gt;From the bottom part, we know the value is 5b-0f-0a-1a-06-04-3b-11-00-04 and we can refer to the meaning of battery I mentioned before:
- Byte[0] --&amp;gt; level in%
- Byte[1-6] --&amp;gt; year (should plus 2000) -month-day-hour-minute-second
- Byte[7-8] --&amp;gt; charge times
- Byte[9] --&amp;gt; status (1 = Battery low, 2 = Battery charging, 3 = Battery full (charging), 4 = Not charging)&lt;/p&gt;
&lt;p&gt;Finally, this value shows that it’s remaining 91% power, last charged time is 2015-10-26-6h-04min-59s, it has been charged 11 times and the status is not charging.&lt;/p&gt;
&lt;h2&gt;Appendix&lt;/h2&gt;
&lt;p&gt;[CON][88:0F:10:DA:5A:39][LE]&amp;gt;&lt;/p&gt;
&lt;p&gt;handle: 0x0002, char properties: 0x02, char value handle: 0x0003, uuid: 00002a00-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0004, char properties: 0x02, char value handle: 0x0005, uuid: 00002a01-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0006, char properties: 0x0a, char value handle: 0x0007, uuid: 00002a02-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0008, char properties: 0x02, char value handle: 0x0009, uuid: 00002a04-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x000d, char properties: 0x22, char value handle: 0x000e, uuid: 00002a05-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0011, char properties: 0x02, char value handle: 0x0012, uuid: 0000ff01-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0013, char properties: 0x0a, char value handle: 0x0014, uuid: 0000ff02-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0015, char properties: 0x12, char value handle: 0x0016, uuid: 0000ff03-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0018, char properties: 0x0a, char value handle: 0x0019, uuid: 0000ff04-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x001a, char properties: 0x08, char value handle: 0x001b, uuid: 0000ff05-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x001c, char properties: 0x12, char value handle: 0x001d, uuid: 0000ff06-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x001f, char properties: 0x12, char value handle: 0x0020, uuid: 0000ff07-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0022, char properties: 0x04, char value handle: 0x0023, uuid: 0000ff08-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0024, char properties: 0x1a, char value handle: 0x0025, uuid: 0000ff09-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0027, char properties: 0x0a, char value handle: 0x0028, uuid: 0000ff0a-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0029, char properties: 0x0a, char value handle: 0x002a, uuid: 0000ff0b-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x002b, char properties: 0x12, char value handle: 0x002c, uuid: 0000ff0c-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x002e, char properties: 0x0a, char value handle: 0x002f, uuid: 0000ff0d-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0030, char properties: 0x1a, char value handle: 0x0031, uuid: 0000ff0e-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0033, char properties: 0x0a, char value handle: 0x0034, uuid: 0000ff0f-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0035, char properties: 0x10, char value handle: 0x0036, uuid: 0000ff10-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0038, char properties: 0x02, char value handle: 0x0039, uuid: 0000fec9-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x003b, char properties: 0x08, char value handle: 0x003c, uuid: 0000fedd-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x003d, char properties: 0x02, char value handle: 0x003e, uuid: 0000fede-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x003f, char properties: 0x02, char value handle: 0x0040, uuid: 0000fedf-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0041, char properties: 0x08, char value handle: 0x0042, uuid: 0000fed0-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0043, char properties: 0x08, char value handle: 0x0044, uuid: 0000fed1-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0045, char properties: 0x02, char value handle: 0x0046, uuid: 0000fed2-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0047, char properties: 0x08, char value handle: 0x0048, uuid: 0000fed3-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x004a, char properties: 0x08, char value handle: 0x004b, uuid: 0000fec7-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x004c, char properties: 0x22, char value handle: 0x004d, uuid: 0000fec8-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x004f, char properties: 0x02, char value handle: 0x0050, uuid: 0000fec9-0000-1000-8000-00805f9b34fb&lt;/p&gt;
&lt;p&gt;handle: 0x0052, char properties: 0x04, char value handle: 0x0053, uuid: 00002a06-0000-1000-8000-00805f9b34fb&lt;/p&gt;</summary><category term="Mi Band"></category></entry><entry><title>进程 &amp;&amp; 线程 part 1</title><link href="http://changy-.github.io/articles/jin-cheng-xian-cheng-part-1.html" rel="alternate"></link><updated>2015-12-27T17:07:00-05:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-12-27:articles/jin-cheng-xian-cheng-part-1.html</id><summary type="html">&lt;h1&gt;进程 &amp;amp;&amp;amp; 线程 part 1&lt;/h1&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多道程序设计: 允许多个程序同时进入内存并运行&lt;/li&gt;
&lt;li&gt;并发环境&lt;/li&gt;
&lt;li&gt;进程: 进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位&lt;/li&gt;
&lt;li&gt;程序的一次执行&lt;/li&gt;
&lt;li&gt;正在运行的程序的抽象&lt;/li&gt;
&lt;li&gt;PCB (process control block)&lt;/li&gt;
&lt;li&gt;process table&lt;/li&gt;
&lt;li&gt;上下文(context)切换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;进程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PCB (process control block)
    PCB是用来描述进程信息的,比如进程的地址,优先级等等.并且进程与PCB是一一对应的.在linux上,输入PS命令旧可以看到当前运行的进程了.&lt;/p&gt;
&lt;p&gt;PCB所包含的信息:
- &lt;strong&gt;进程描述信息&lt;/strong&gt;
进程标识符(process ID)，唯一，通常是一个整数
进程名，通常基于可执行文件名，不唯一
用户标识符(user ID)
进程组关系
- &lt;strong&gt;进程控制信息&lt;/strong&gt;
当前状态
优先级(priority)
代码执行入口地址
程序的磁盘地址
运行统计信息(执行时间、页面调度)
进程间同步和通信
进程的队列指针
进程的消息队列指针
- &lt;strong&gt;所拥有的资源和使用情况&lt;/strong&gt;
虚拟地址空间的状况
打开文件列表
- &lt;strong&gt;CPU现场信息&lt;/strong&gt;
寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
指向该进程页表的指针&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前3者比较好理解,最后一部分,CPU现场信息,是为了切换进程时保存当前运行的状态.
 在Linux中,进程结构名是TASK_STRUCT,这个结构体包含很多个进程的信息,可以google一下.
 重点记录一下图中的3个信息:
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2017:29:56.png?raw=true" /&gt;
 p_exec保存的是可执行文件的入口地址, p_as保存的是进程地址空间,在这个空间内部,是使用一刻AVL树,方便运行时候的查找, u_info记录的是打开的文件.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程状态 &amp;amp;&amp;amp; 状态转换
 有三状态,无状态和七状态
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2017:36:41.png?raw=true" /&gt;
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:20:09.png?raw=true" /&gt;
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:20:26.png?raw=true" /&gt;
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2017:37:56.png?raw=true" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程控制
 创建,注销,阻塞等操作.
 这里主要记录fork()函数
 - 为子进程分配一个空闲的进程描述符proc 结构
 - 分配给子进程唯一标识 pid
 - 以一次一页的方式复制父进程地址空间
 - 从父进程处继承共享资源，如打开的文件和当前工作目录等
 - 将子进程的状态设为就绪，插入到就绪队列
 - 对子进程返回标识符 0
 - 向父进程返回子进程的 pid&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单概括就是,子进程复制了父进程,但是,这里也有一个缺点,由于子进程的工作肯定是和父进程不太相关的,后期会调用exec()函数来覆盖这部分的PCB,所以复制了父进程的信息也并没有什么用处,反而会浪费资源. 在Linux中,对这种机制进行了改进,调用fork()后,并不是复制父进程的结构体,而是返回一个指向内存的一个指针,然后采用Copy-On-Write技术,即程序需要写的时候再copy进来,这样,效率旧高了很多.&lt;/p&gt;
&lt;p&gt;一段fork()代码
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2017:47:55.png?raw=true" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程控制
 OS给每个进程都分配了一个地址空间????
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2017:52:25.png?raw=true" /&gt;
 这段代码很好理解,输出传进去的参数的值和地址.
 我们同时运行2个该程序.
 &lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:22:48.png?raw=true" /&gt; &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出,不同的程序,变量却是相同的地址,其实这里使用的是虚拟地址空间,并不是实际的内存地址.&lt;/p&gt;
&lt;h2&gt;线程&lt;/h2&gt;
&lt;p&gt;线程的典型应用:
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:08:07.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;线程:
- 有标示符ID
- 有状态及状态转换 → 需要提供一些操作
- 不运行时需要保存的上下文
 有上下文环境：程序计数器等寄存器
- 有自己的栈和栈指针 √
- 共享所在进程的地址空间和其他资源
- 可以创建、撤消另一个线程&lt;/p&gt;
&lt;p&gt;线程分为用户级线程,核心级线程和混合型.
用户级:
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:11:45.png?raw=true" /&gt;
优点：
 线程切换快
 调度算法是应用程序特定的
 用户级线程可运行在任何操作系统上（只需要实现线程库）
缺点：
 内核只将处理器分配给进程，同一进程中的两
个线程不能同时运行于两个处理器上
 大多数系统调用是阻塞的，因此，由于内核阻
塞进程，故进程中所有线程也被阻塞&lt;/p&gt;
&lt;p&gt;核心级:
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:13:08.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;混合型:
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-27%2018:13:43.png?raw=true" /&gt;&lt;/p&gt;</summary><category term="system"></category></entry><entry><title>中断 &amp;&amp; 异常 &amp;&amp; 系统调用</title><link href="http://changy-.github.io/articles/zhong-duan-yi-chang-xi-tong-diao-yong.html" rel="alternate"></link><updated>2015-12-26T10:57:00-05:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-12-26:articles/zhong-duan-yi-chang-xi-tong-diao-yong.html</id><summary type="html">&lt;h1&gt;中断 &amp;amp;&amp;amp; 异常 &amp;amp;&amp;amp; 系统调用&lt;/h1&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;操作系统需要两种CPU状态:
 内核态(Kernel Mode)：运行操作系统程序
 用户态(User Mode)：运行用户程序&lt;/p&gt;
&lt;p&gt;用户态 → 内核态
- 唯一途径 → 中断/异常/陷入机制&lt;/p&gt;
&lt;p&gt;内核态 → 用户态
- 设置程序状态字PSW&lt;/p&gt;
&lt;p&gt;系统调用就属于第二种. (访管指令)&lt;/p&gt;
&lt;h3&gt;中断和异常&lt;/h3&gt;
&lt;p&gt;中断和异常是操作系统的驱动.&lt;/p&gt;
&lt;p&gt;中断(外中断), 是外部事件,导致硬件的中断:
- I/O 中断
- 时钟中断
- 硬件故障&lt;/p&gt;
&lt;p&gt;异常(内中断), 是由CPU运行的指令而产生的:
- 系统调用
- 页故障
- 保护性异常
- 断点指令(调试程序)
- 其他&lt;/p&gt;
&lt;p&gt;示意图如下:
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-26%2010:24:15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;可以看出,最关键是的如何使用向量表找到中断程序的入口地址.
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-26%2010:28:07.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;通过GDT找到段基址,通过IDT找到偏移量,这样就可以知道中断程序的入口地址了.&lt;/p&gt;
&lt;h3&gt;系统调用&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-26%2010:39:22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-26%2010:48:54.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;这是write(1,"hello",7)的汇编代码,可以看到,通过压栈存储所有的变量,然后执行int 0x80 产生系统调用.
最后,举一个linux中系统调用的例子:
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/Screenshot%20from%202015-12-26%2010:52:07.png?raw=true" /&gt;&lt;/p&gt;</summary><category term="system"></category></entry><entry><title>Ubuntu 14.04 编译wireshark source</title><link href="http://changy-.github.io/articles/ubuntu-1404-bian-yi-wireshark-source.html" rel="alternate"></link><updated>2015-11-07T18:27:00-05:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-11-07:articles/ubuntu-1404-bian-yi-wireshark-source.html</id><summary type="html">&lt;h1&gt;Ubuntu 14.04 编译wireshark source&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;由于通过&lt;code&gt;apt-get install wireshark&lt;/code&gt;安装的wireshark版本比较旧，不支持BLE协议。所以，得下载源代码进行编译。&lt;/p&gt;
&lt;p&gt;1.下载wireshark的源代码
2.安装必要的依赖库&lt;code&gt;sudo apt-get build-dep wireshark&lt;/code&gt;
3.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cd wireshark
./configure
make -j8
make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，大部分情况下，这样是会有错误的。尤其是在&lt;code&gt;./configure&lt;/code&gt;后，会报缺少一些库，这个时候可以根据缺少的库，一个个的安装。&lt;/p&gt;
&lt;p&gt;我的情况下是缺少qt相关的库，google后，还是不能解决：qt is not found 或者 can't find uci.
可以参考：&lt;a href="http://stackoverflow.com/questions/25965807/qt-is-not-available-error-while-compiling-a-wireshark-1-12"&gt;qt is not found&lt;/a&gt;，&lt;a href="https://ask.wireshark.org/questions/28105/qt-not-available-error"&gt;Qt not available error?&lt;/a&gt;
我有尝试&lt;code&gt;apt-get install qt5-default&lt;/code&gt;和&lt;code&gt;apt-get install qt4-default&lt;/code&gt;，最后依然报错。&lt;/p&gt;
&lt;p&gt;最终，看到了这个&lt;a href="https://community.gns3.com/community/forum/blog/2015/01/21/how-to-build-wireshark-1123-from-scratch-in-ubuntu"&gt;使用GTK安装wireshark&lt;/a&gt;，安装qt会有各种错误，使用这个后，很顺利的安装成功了。&lt;/p&gt;
&lt;p&gt;对于报qt错的同学，可以参考下这个&lt;a href="https://www.howtoinstall.co/en/ubuntu/utopic/universe/wireshark-qt/"&gt;这个&lt;/a&gt;&lt;/p&gt;</summary><category term="wireshark"></category></entry><entry><title>Programming language 2</title><link href="http://changy-.github.io/articles/programming-language-2.html" rel="alternate"></link><updated>2015-11-06T10:32:00-05:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-11-06:articles/programming-language-2.html</id><summary type="html">&lt;h1&gt;&lt;strong&gt;Programming Language 2&lt;/strong&gt;&lt;/h1&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;刚刚结束这门课的期中考试，老师讲课内容很深，考试也很难，并且提高了自己对编程语言的理解，有必要做一个记录。&lt;/p&gt;
&lt;p&gt;这一部分对应的是Algol68和Python里的一些特性。&lt;/p&gt;
&lt;h2&gt;Referfence &amp;amp; Value&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;x=x+2&lt;/code&gt;,这个赋值中x是int型，按照我们的理解是把x的值加上2再赋值给x。然而，这只是现代的编程语言高度抽象化后的结果。
&lt;code&gt;int x&lt;/code&gt;，表示我们申明了一个整型，name是x。在Algol68中，这表示的是x是指向int的引用。
&lt;code&gt;x=x+2&lt;/code&gt;，右边的x会deref，从引用变为int，然后相加，最后x再指向这个int值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/003.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;最后，y=2，x=5。
在这个图中，&lt;code&gt;r:=3&lt;/code&gt;,3是int值，而左边的r是引用，指向的是x，也可以理解成 ref ref int类型。最后一个问题，z会不断deref，直到找到int值。&lt;/p&gt;
&lt;h2&gt;Array&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;维度：
在数组中，类型变得不重要了，反而维度很重要。相同的维度，他们就是相同的。
[1:100,1:n] real 与 [1:10,7:11] int  是相同的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态数组：
&lt;code&gt;Flex [1:0] int obj&lt;/code&gt;数组长度为0，动态的，当赋值的时候才确定长度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Structure&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mode bin_tree = struct(int data, REFbin_tree l_child, r_child)&lt;/code&gt;支持递归定义。&lt;/p&gt;
&lt;h2&gt;Union&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mode combine = UNION(int,bool)&lt;/code&gt;
&lt;code&gt;combine x&lt;/code&gt;，这里，x可以是int也可以时bool型&lt;/p&gt;
&lt;h2&gt;Expression&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/004.png?raw=true" /&gt;&lt;/p&gt;
&lt;h2&gt;Iterator&lt;/h2&gt;
&lt;p&gt;迭代器是个好东西！！！！！
参考&lt;a href="https://en.wikipedia.org/wiki/Iterator"&gt;这里&lt;/a&gt;。
&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/005.png?raw=true" /&gt;&lt;/p&gt;</summary><category term="class"></category></entry><entry><title>Porgramming Language 1</title><link href="http://changy-.github.io/articles/porgramming-language-1.html" rel="alternate"></link><updated>2015-11-04T15:46:00-05:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-11-04:articles/porgramming-language-1.html</id><summary type="html">&lt;h1&gt;&lt;strong&gt;Porgramming Language 1&lt;/strong&gt;&lt;/h1&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;刚刚结束这门课的期中考试，老师讲课内容很深，考试也很难，并且提高了自己对编程语言的理解，有必要做一个记录。&lt;/p&gt;
&lt;p&gt;这一部分对应的是Fortran和Algol60。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Fortran&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;一些重要的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Functions(not subroutines)&lt;/li&gt;
&lt;li&gt;Common blocks&lt;/li&gt;
&lt;li&gt;Definete loops&lt;/li&gt;
&lt;li&gt;Operateor overloading(not user-defined)&lt;/li&gt;
&lt;li&gt;on intergers and reals&lt;/li&gt;
&lt;li&gt;Type coersion&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Fortran里，二维数组是按列存储的。这点比较反人类。并且所有的数据都是静态分配的（后面会提到动态分配）。
最重要的是理解GOTO这个关键字的意义和对后来者的影响。
Programming 作业就是用Fortran实现一个BNF（可以理解成写正则表达式）。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Algol60&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这是First design-by-commitee language。&lt;/p&gt;
&lt;p&gt;一些重要的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IF was an &lt;strong&gt;expression&lt;/strong&gt; not a statement&lt;/li&gt;
&lt;li&gt;Block structure and &lt;strong&gt;scoping&lt;/strong&gt; rules&lt;/li&gt;
&lt;li&gt;Structured, nestablecontrol statements &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic bounds on arrays&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Call by value&lt;/strong&gt; and &lt;strong&gt;call by name&lt;/strong&gt; for procedure parameters&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic variable lifetime&lt;/strong&gt;*&lt;/li&gt;
&lt;li&gt;BNF –Backus-Naur Form&lt;/li&gt;
&lt;li&gt;Recursion (and thus, &lt;strong&gt;stack-based computation model&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;加粗部分是比较重要的概念，像Java，Python都有用到这些方法。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;statement vs expression&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/001.PNG?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;如果有疑问，可以参考&lt;a href="http://stackoverflow.com/questions/4728073/what-is-the-difference-between-an-expression-and-a-statement-in-python"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;variable&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;Address&lt;/strong&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Variables may not live at the same address&lt;/li&gt;
&lt;li&gt;Multiple variables may share an address: aliasing&lt;/li&gt;
&lt;li&gt;This can change as the program changes&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    1   #include &amp;lt;stdio.h&amp;gt;
    2       intmain() {
    3       char *x = &amp;quot;This is an example&amp;quot;;
    4       char *y = x;
    5       printf(&amp;quot;%p\n&amp;quot;, y);
    6       y = NULL;
    7       printf(&amp;quot;%p\n&amp;quot;, y);
    8   }

        0x1053e3f7a
        0x0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;熟悉c的同学这段代码应该没问题的。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Binding&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;绑定，在这里指的是变量和内存地址的绑定，主要分为3个阶段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;compile time: 一些全局变量或者const等&lt;/li&gt;
&lt;li&gt;load time：静态变量。 我自己理解这里花了很长的时间，不太懂load time是哪一段时间，看了下wiki：https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase) 才明白的，简而言之，load time就是运行程序时，程序在内存中，这个时候，loader会扫描程序，分配地址，一切完成后，程序才运行，就到了run time。&lt;/li&gt;
&lt;li&gt;run time：这里比较复杂，有些语言是stack allocation的，在函数中的变量就会不断的绑定和销毁。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Static binding: happens before runtime&lt;/p&gt;
&lt;p&gt;Dynamic binding: happens during runtime&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;Scope &amp;amp; Lifetime&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;这2个是特别容易混淆的概念。Scope是指变量有意义的范围，Lifetime就是生命周期。乍一看起来，2者是一样的，其实对不同的编程语言，有很大的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scope&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    float pi = 3.1415927;

    float calc_area(float r) {
    return pi * r * r;
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很显然，在&lt;code&gt;calc_area()&lt;/code&gt;函数中可以知道pi的值，也就是说pi的scope包括了&lt;code&gt;calc_area()&lt;/code&gt;函数。这是静态的。&lt;/p&gt;
&lt;p&gt;动态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    func f1() {
        x = 10;
        f2();
    }
    func f2() {
        print(x);
        print(z);
    }
    x = 1;
    z = 1;
    f1();
    f2();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果是10,1,1,1
dynamic scoping 是上下文相关的。&lt;/p&gt;
&lt;p&gt;流程图：
&lt;img alt="流程图" src="https://github.com/Changy-/Changy-.github.io/blob/master/images/002.PNG?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;当需要x变量时，函数会不断往外寻找，这就是动态的原因。&lt;/p&gt;
&lt;p&gt;2.lifetime&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    char *copy(char *str) {
        inti, l;
        l = strlen(str);
        char *ret = (char *)malloc(l);
        for (i=0; i&amp;lt;= l; i++) {
            ret[i] = str[i];
        }
        return ret;
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于这段代码，copy()函数结束后，变量ret就销毁了吗？
并不是这样的。ret是通过malloc得来的，此时，ret并不是存在stack中，而是存在heap中。（不太懂得同学可以参考&lt;a href="http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html"&gt;这里&lt;/a&gt;或者百度，上面有很多解释。）这样，只有programmer调用free时，ret变量才会被内存销毁。
所以，ret的lifetime比scope要大。&lt;/p&gt;
&lt;p&gt;总结一下就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Static allocation: statically bound to a memory address(整个run time)&lt;/p&gt;
&lt;p&gt;Stack allocation: local variable w/ automatic allocation&lt;/p&gt;
&lt;p&gt;Heap allocation: dynamically allocated at runtime (via mallocor similar)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Parameter passing&lt;/strong&gt;
这也是很重要的概念。
熟悉C语言的同学都知道，C是值传递的(pass-by-value)，调用swap(int a,int b)并不难交换2个数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;pass-by-name: 只有在需要的时候才赋值。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    x=[1,2,3,4,5,6,7,8,9,10]
    i=10
    int sum(ix,l.u,item){
        s=0
        for(ix=l; ix &amp;lt;= u; ix++){
            s=s+item
        }
    }
    sum(i,1,10,x[i])
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;结果是55，而不是100。
因为x[i]并不是在传参的时候被实例化了，而是在&lt;code&gt;s=s+item&lt;/code&gt;中才被赋值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pass-by-value:
C语言使用的就是这个，没什么好说的。不过，在java和Python中，基本类型也是使用的这个，而高级类型（如：对象）使用的是pass-by-reference&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pass-by-reference: 相当于有一个指针指向了变量，在函数内部，形参改变了，实参也改变了。因为这2者是指向同一个地址的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pass-by-result:和pass-by-reference差不多，也是和实参指向同一个地址，但是，区别在于，pass-by-result的形参不能读取，只能输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pass-by-value-resule:可以理解成copy in &amp;amp; copy out，效果可pass-by-reference一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后附上他们的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pass-by-name&lt;ul&gt;
&lt;li&gt;-Too unintuitive&lt;/li&gt;
&lt;li&gt;-Parameters evaluated each use –could get expensive in a loop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pass-by-reference&lt;ul&gt;
&lt;li&gt;+More efficient than copying&lt;/li&gt;
&lt;li&gt;-Aliasing leads to unexpected side-effects&lt;/li&gt;
&lt;li&gt;-How to handle an expression as an argument?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pass-by-value&lt;ul&gt;
&lt;li&gt;+Argument protected from changes in callee&lt;/li&gt;
&lt;li&gt;+No unintended side-effects&lt;/li&gt;
&lt;li&gt;-Execution time and space, especially for arrays, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pass-by-result&lt;ul&gt;
&lt;li&gt;+Manifest interface&lt;/li&gt;
&lt;li&gt;-fnfunc(a, b : int);  func(m, m);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="class"></category></entry><entry><title>自定义Vim配置</title><link href="http://changy-.github.io/articles/zi-ding-yi-vimpei-zhi.html" rel="alternate"></link><updated>2015-09-07T22:32:00-04:00</updated><author><name>Changy</name></author><id>tag:changy-.github.io,2015-09-07:articles/zi-ding-yi-vimpei-zhi.html</id><summary type="html">&lt;p&gt;配置源码都在  &lt;code&gt;https://github.com/Changy-/vim&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;贴上&lt;a href="https://github.com/Changy-/vim/blob/master/.vimrc"&gt;.vimrc&lt;/a&gt;,根据你自身情况,可以直接再这里修改,每个参数的意义也比较清楚.&lt;/p&gt;
&lt;p&gt;如若需要修改主题,&lt;code&gt;color rainbow_neon&lt;/code&gt; 把rainbow_neon改成主题名就行了.我的源码的/colors目录下集成了很多主题,可以任意选择. 如需添加主题,将主题.vim文件copy至~/.vim/colors中,再更改.vimrc即可.
推荐一个主题站 &lt;code&gt;http://vimcolorschemetest.googlecode.com/svn/html/index-html.html&lt;/code&gt; 作为参考&lt;/p&gt;
&lt;p&gt;再者,在这里提醒一下,本人是再ubuntu14.04 gnome下使用该方法,由于我的terminal也有主题,故而会使得vim的主题颜色发生剧烈变化. Ps:我因此怀疑了好久自己的审美观.....  另外一种bug就是要设置为256色.
如果你也有同样的问题,可以参考&lt;a href="http://stackoverflow.com/questions/10778078/vim-colorscheme-executing-but-not-changing-colors"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;截图:&lt;/h2&gt;
&lt;p&gt;&lt;img alt="截图" src="https://github.com/Changy-/vim/blob/master/screenshot.png?raw=true" title="截图" /&gt;&lt;/p&gt;
&lt;p&gt;有任何问题,欢迎在评论区提出, 或者email我: changy.smali@gmail.com&lt;/p&gt;</summary><category term="Vim"></category></entry><entry><title>Just_Try</title><link href="http://changy-.github.io/articles/just_try.html" rel="alternate"></link><updated>2015-08-28T15:35:00-04:00</updated><author><name>changy</name></author><id>tag:changy-.github.io,2015-08-28:articles/just_try.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;The first Markdown.
&lt;/pre&gt;&lt;/div&gt;</summary><category term="other"></category></entry></feed>